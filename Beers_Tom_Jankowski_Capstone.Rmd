---
title: "Canned Craft Beer Recommender.Rmd"
author: "Tom_Jankowski"
date: "10/14/2019"
output: pdf_document
toc: true
toc_depth: 3
number_sections: true
theme: united
highlight: tango
---

# Canned Craft Beer Recommender Application  
## A Beerage of Choices!
### Analysis in R -- by Tom Jankowski  

# Package and Library installation and loading.  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#update.packages(ask = FALSE)
#install.packages("rstan")
#install.packages('dendextend')
#install.packages("ggdendro")
#install.packages('ape')
#install.packages("caret")
library("ape")
library("tidyverse")
library("rattle")
library("rpart")
library("caret")
library("ranger")
library("lubridate")
library("dendextend")
library("gridExtra")
library("ggdendro")
library("ggplot2")

# Set Seed
set.seed(123)
```

# Dataset
## Canned beer dataset obtained from kaggle.com: [link] (https://www.kaggle.com/nickhould/craft-cans). 

The dataset consists of two files:  
  - beers.csv (2410 obs. of 8 variables).  
  - breweries.csv (558 obs of 4 variables).  
More detailed analysis of each dataset is provided in Exploratory Data Analysis (EDA) section below.

```{r}
beers <- read_csv('beers_updated.csv')
breweries <- read_csv('breweries.csv')
```

# Craft Canned Beer Recommender Application -- Business Case  

Craft beer drinkers use different forms of information to select a beer. These include beer price, style, beer name, labeling, alcohol by volume (abv), international bitterness units (ibu), flavor profile, brewery, and the access they have to beers in thier local city, state, and brewery taphouses. Unless you live under a rock, you've no doubt noticed the booming craft beer market. According to the Brewers Association - an American trade group representing craft brewers, suppliers, and distributors, sales account for 24% of the U.S. beer market worth over $114 billion. Beer in the U.S. is manufactured by more than 7,000 breweries, which range in size from industry giants to brew pubs and microbreweries. With thousnds of brews to choose from, how do beer lovers choose a beer among a dizzying array of beer options. This is where the **Craft Canned Beer Rcommender App** helps make these choices a bit easier. The **Craft Canned Beer Rcommender App** is designed to help customers of beer retailers (such as liqour stores, grocery stores, and convenient stores) choose a beer based on a set of criteria including: beer abv, beer ibu, beer name, beer style, brewery name, city and state. Reatilers who offer its customers with the option to use the Craft Canned Beer Rcommender App will provide a better service to its customers increasing customer satisfation and loyalty, which increase sales and profit.


# Data cleaning and wrangling on the **breweries** dataset.  

## Descriptive statistics provides a quick summary of the features in the beers dataset.  

```{r}
summary(beers)
```

## Glimpse provides a quick look at the actual data values in the beers dataset.  

```{r}
glimpse(beers)
```

## Data cleaning and wrangling on the **breweries** dataset.  

## Descriptive statistics provides a quick summary of the features in the breweries dataset.  

```{r}
summary(breweries)
```

## Glimpse provides a quick look at the actual data values in the breweries dataset.  

```{r}
glimpse(breweries)
```

## Join the 2 datasets  
### Left Join  

To work with both datasets, I will need to perform a left join (beers to breweries). Here I am creating a new data frame named **dat**.
```{r}
dat <- beers %>% 
left_join(breweries, by = c('brewery_id' = 'X1'))
```

## A glimpse at the joined dataset shows my columns, datatypes, and sample values.  

```{r}
glimpse(dat)
```

As seen above, the column names need cleaning. Here I will rename some of the columns so they are more readable, and not duplicative. This will require removing the **X1** id, **id**, and **brewery_id** columns as they will not be useful in the analysis and modeling. Also, for readability, I will change the beer name column **name.x** to beer_name and the **name.y** column to brewery_name. Here I am creating a new data frame named **dat_selected**.

```{r}
dat_selected <- dat %>%
  rename(beer_name = name.x) %>% 
  rename(brewery_name = name.y) %>%
  mutate(ounces = round(ounces, 0)) %>% 
  mutate(ounces = as.factor(ounces)) %>% 
  select(-id, -brewery_id, -X1)
```

The new **dat_selected** dataframe contains 2410 observations and 8 columns.

# Handling Missing Values  
# Handling NAs  

I need to determine the sum and proportion of missing values in my joined dataset. As seen below, It appears that I have a number of missing values across the columns that must be addressed.

```{r}
colSums(is.na(dat_selected))
round(colSums(is.na(dat_selected)) / nrow(dat_selected), 4)
```

The .08% (2 obs.) missing values in the **style** column are not of concern since after examining these rows, I have determined that they are inaccurate and do not actually contain beer data. They will be deleted.

```{r}
dat_selected <- dat_selected[-c(1555, 1556), ]
```

```{r}
dat_selected %>% 
  group_by(brewery_name) %>% 
  summarise(n=n())
```


The larger concern is the 41.62% (1003 obs.) missing values in the **ibu** column. These missing values, along with the 1.16% (28 obs.) in the **abv** column could be handled in a number of ways. To determine a course of action, I will examine any potential associations between **ibu** and other variables.   

First I will examine the distribution of ibu NAs in the style column. 

```{r}
dat_selected %>% 
  group_by(style) %>% 
  filter(is.na(ibu)) %>% 
  count() %>% 
  ggplot(aes(x=style, y = n)) +
  geom_point()
```
The proportion of ibu NAs related to syle don't appear to have a relationship.

```{r}
ibu_na <- dat_selected %>% 
  group_by(style) %>% 
  filter(is.na(ibu)) %>% 
  summarise(ibu_na = n()) %>%
  arrange(desc(ibu_na)) %>% 
  ungroup() %>% 
  select(ibu_na)
ibu_na
```

```{r}
ibu_non_na <- dat_selected %>% 
  group_by(style) %>% 
  filter(!is.na(ibu)) %>% 
  summarise(ibu_value = n()) %>%
  arrange(desc(ibu_value)) %>% 
  ungroup() %>% 
  select(ibu_value)
ibu_non_na
```

## ABV NAs -- Analysis of missing values  

A look at the missing abv values.

```{r}
dat_selected %>% 
  group_by(style) %>% 
  filter(is.na(abv)) %>% 
  count() %>% 
  ggplot(aes(x=style, y = n)) +
  geom_point()
```

Missing abv values.

```{r}
abv_na <- dat_selected %>% 
  group_by(style) %>% 
  filter(is.na(abv)) %>% 
  summarise(abv_na = n()) %>%
  arrange(desc(abv_na))
#  ungroup()
#  select(abv_na)
abv_na
```

ABV values not missing.

```{r}
abv_non_na <- dat_selected %>% 
  group_by(style) %>% 
  filter(!is.na(abv)) %>% 
  summarise(abv_value = n()) %>%
  arrange(desc(abv_value))
#  ungroup()
#  select(abv_value)
abv_non_na
```

```{r}

```

# Exploratory Data Analysis (EDA)  

With a joined and clean dataset, I will analyze the data to identify distributions and any variable relationships. The first analysis that interests me is the beer styles that are most common. I will use a bar chart to show this distribution. We can see that IPAs, Pale ales and other ales dominate the most common styles.

```{r}
dat_selected %>% 
  group_by(style) %>%
  summarise(count = n()) %>%
  filter(count > 50) %>%
  ggplot(aes(reorder(style, count), count)) +
  geom_col(fill = "tan") +
  coord_flip() +
  labs(title = "Top Beer Styles", subtitle = "Greater than 50 beers", x = "Sum of Beer Styles > 50", y = "Beer Styles")
```

## Top 10 States for craft beer in the dataset.  

```{r}
top_10_states <- dat_selected %>% 
  group_by(state) %>% 
  summarise(top_10 = n()) %>% 
  arrange(desc(top_10))
#  top_n(10)

top_10_states
```

## Top 10 cities for Breweries  
```{r}
num_cities <- breweries %>%
  group_by(city) %>%
  summarise(number_of_breweries = n()) %>%
  arrange(desc(number_of_breweries))
head(num_cities,10)
```

## Who Likes Bittert Beer?  
```{r, warning=F}
dat_selected %>%
  group_by(state) %>%
  mutate(mean_ibu = mean(ibu, na.rm = TRUE)) %>%
  ggplot(aes(x = reorder(state, -mean_ibu), y = ibu, fill = mean_ibu)) + 
  geom_boxplot() + 
  labs(x = "state", y = "Beer IBU", title = "Who Likes Bitter Beer?")
```


## ABV / IBU Relationship  

```{r, warning=F}
dat_selected %>%
  select(ibu, abv) %>%
  ggplot(aes(abv, ibu)) + 
  geom_point(alpha = .4) +
  geom_smooth(method = lm, color = 'blue')
```

### Cleaning missing ABV and IBU data values  
```{r}
dat_abv_clean <- dat_selected %>% 
  group_by(style) %>% 
  mutate(abv = if_else(is.na(abv), mean(abv, na.rm = TRUE), abv),
         ibu = if_else(is.na(ibu), mean(ibu, na.rm = TRUE), ibu)) %>% 
  ungroup()
```

```{r}
dat_ibu_clean <- dat_abv_clean %>%
  group_by(style) %>% 
  mutate(ibu = if_else(is.na(ibu), mean(ibu), ibu)) %>% 
  ungroup()
```

### Creating dataset with complete cases  
```{r}
dat_clean_cases <- dat_ibu_clean %>% 
  filter(complete.cases(dat_ibu_clean))
```

### Rounding ABV and IBU data for standardization  
```{r}
dat_clean <- dat_clean_cases %>%
  mutate(ibu = round(ibu, 0),
         abv = round(abv, 3))
dat_clean
```

### Final look at missing values  
As we can see, all the features have 0 missing values.  
```{r}
colSums(is.na(dat_clean) / nrow(dat_clean))
```

## Looking at duplicates in the beer_name column  
```{r}
dat_clean %>% 
  group_by(beer_name, ounces) %>% 
  count() %>% 
  arrange(beer_name) %>% 
  arrange(desc(n))
```

## Adding ounces to beer name column and removing columns with duplicate beer names.
```{r}
dat_model <- dat_clean %>% 
  mutate(beer_name = paste0(beer_name, "-", ounces)) %>% 
  distinct(beer_name, .keep_all = TRUE) %>% 
  mutate(id = row_number()) %>% 
  select(-ounces)
```

## Data Split Train / Test  based on a predefined set of known and recognizable beer names  
```{r}
test_beer_names <- c("Fat Tire Amber Ale-12", "Fat Tire Amber Ale-16", "White Rascal-12", "Boston Lager-12",
                     "Boston Lager-16", "Mirror Pond Pale Ale-12", "1554 Black Lager-12", "Dale's Pale Ale (2012)-12",
                     "Mama's Little Yella Pils-12", "Mama's Little Yella Pils-19", "Monarch Pilsner-12",
                     "Upslope Brown Ale-12", "G'KNIGHT (12 oz.)-12", "G'KNIGHT (16 oz.)-16", "Hop Crisis-12",
                     "Sculpin IPA-12", "Todd the Axe Man-16", "Wyoming Pale Ale-16", "Samuel Adams Winter Lager-12",
                     "Laughing Dog Cream Ale-12", "Apricot Blonde-12", "TailGate Hefeweizen-12",
                     "TailGate Hefeweizen-24", "Easy Day Kolsch-12", "Kilt Lifter Scottish-Style Ale-12",
                     "Grateful White-12", "Hazy Day Belgian-Style Wit-16", "Vivant Tripel (2012)-16", "Righteous Ale-16",
                     "Crabtree Oatmeal Stout-16")

dat_test_compare <- dat_model %>%
  filter(beer_name %in% test_beer_names)

dat_train_cluster <- dat_model %>% 
 anti_join(dat_test_compare, by = 'id') %>%
 select(-id)

dat_test_compare <- dat_test_compare %>% 
  select(-id)
```

### Original train / test split code  
```{r}
#dat_model <- dat_model %>% 
#  mutate(id = row_number())

#dat_train <- dat_model %>%
#  sample_frac(0.75)

#dat_test <- dat_model %>%
# anti_join(dat_train, by = 'id') %>%
# select(-id) %>%
#  column_to_rownames("beer_name")

#dat_train <- dat_train %>%
# select(-id) %>%
# sample_n(50) %>% 
# column_to_rownames("beer_name")
```

# ----- MODELING STARTS HERE ----- ###

## Preprocessing  
Pre-processing using **Standardization**, which combines both scaling and centering transformations.   
```{r}
#dat_train <- dat_train %>% sample_n(50)
model_pp <- preProcess(dat_train_cluster, method = c('center', 'scale'))
dat_train_pp <- predict(model_pp, dat_train_cluster)
dat_train_pp
```

## Hieracrhical Clustering Model and Plot (Tuned for easy viewing)  
```{r, fig.height=5.5, fig.width=10}
dat_train_dendro <- dat_train_pp %>%
  sample_n(50) %>% 
  column_to_rownames("beer_name")

distance_data <- dist(dat_train_dendro, method = 'euclidean')
hc_complete <- hclust(distance_data, method = 'complete')
plot(hc_complete, hang = -1, cex = 0.6)
```

### Colored Dendrogram  
```{r, fig.height=10, fig.width=10}
k_val <- 5
hc_complete_dendro <- as.dendrogram(hc_complete)
dend_colored <- hc_complete_dendro %>%
  color_branches(k = k_val) %>%
  color_labels(k = k_val) %>% 
  set("labels_cex", .6)
plot(dend_colored, cex = 0.6, type = "rectangle")
```

```{r, fig.height=10, fig.width=10}
cols <- c("#a9a9a9", "#1f77b4", "#ff7f0e", "#2ca02c")
p <- ggdendrogram(hc_complete_dendro,
                   direction   = "tb",
#                   scale.color = cols,
                   label.size  = 2.5,
                   branch.size = 0.5,
                   expand.y    = 0.2)
mytheme <- theme(axis.text          = element_text(color = "blue"),
                 panel.grid.major.y = element_line(color = "tan",
                                                   size  = 0.25))
p + mytheme
```


## Hieracrhical Clustering Model (with full data to generate final clusters)   
```{r, fig.width=10}
distance_data_all <- dist(dat_train_pp, method = 'euclidean')
hc_complete_all <- hclust(distance_data_all, method = 'complete')
plot(hc_complete_all, hang = -1, cex = 0.6)
```

### Cutting the hcust to 5 and creating Class for classification model  
Below I am using the cutree function to trim the hclust to 5. The clusters are being used to create
a **Class** variable for the random forest (ranger) classification model.
```{r}
hc_cut <- cutree(hc_complete_all, 5)

dat_class_model <- dat_train_pp %>%
  mutate(Class = as.factor(hc_cut)) %>%
  select(abv, ibu, style, state, Class) %>% 
  mutate(style = as.factor(style),
         state = as.factor(state),
         style = fct_lump(style, n = 25),
         state = fct_lump(state, n = 25))
```

Let's take a look at the composition of the 5 clusters and the relationship between abv and ibu.
```{r}
#dat_class_model$cluster <- hc_cut
dat_class_model %>%
  group_by(style) %>%
  count() %>%
  arrange(n)

dat_class_model %>%
  ggplot(aes(x = abv, y = ibu, col = Class)) +
  geom_point()
```

## Split Train / Test for the Random Forest Model  
Here I have incorporated a custom function to perform the train / test split.
```{r}
split_train_test = function(df, train_pct = 0.70, seed_number = 123){
  set.seed(seed_number)
# ID for splitting
  df_id <- df %>% 
    mutate(split_id = row_number())
# Train set  
  df_train <- df_id %>%
    sample_frac(train_pct)
# Test set  
  df_test <- df_id %>%
    anti_join(df_train, by = 'split_id') %>%
    select(-split_id)
# Remove the ID
  df_train <- df_train %>%
    select(-split_id)
# Create dfs  
  df_split <- list(train = as.data.frame(df_train), test = as.data.frame(df_test))
  return(df_split)
}
```

Below I perform the Train / Test Split using the **split_train_test** custom function, and I create
both the final train and test data frames for use in the rf model and the predictions.  
```{r}
dat_split_rf <- split_train_test(dat_class_model, train_pct = 0.75, seed_number = 789)

dat_train_rf <- dat_split_rf$train
dat_test_rf <- dat_split_rf$test
```

## Up Sampling for the cluster Class variable  
```{r}
dat_train_up_rf <- upSample(dat_train_rf %>% select(-Class), dat_train_rf$Class)
```
Look at the UpSample results 
```{r}
table(dat_train_up_rf$Class)
```

UpSample Results
```{r}
dat_train_up_rf %>% 
  group_by(Class) %>% 
  count()
```


# ---- Classification Model ----
## Predicting cluster  

```{r}
train_control <- trainControl(method = 'cv', number = 5, allowParallel = TRUE)

model_rf <- train(dat_train_up_rf %>% select(-Class),
                  dat_train_up_rf$Class,
                  method = 'ranger',
                  importance = "impurity",
                  trControl = train_control)

model_rf$finalModel$variable.importance
```

```{r}
model_rf$results
```

```{r}
predictions <- predict(model_rf, newdata = dat_test_rf)
predictions
```
### Random Forest Confusion Matrix  
Let's take a look at the results of the confusion matrix and statistics. We can see that the forest model is predicting at 99%.
```{r}
confusionMatrix(predictions, dat_test_rf$Class)
```
## Compare the hold-out dataset to the predicted data  
```{r}
dat_test_compare_final <- dat_test_compare %>% 
  select(abv, ibu, style, state)

model_test_pp <- preProcess(dat_test_compare_final, method = c('center', 'scale'))
dat_test_pp <- predict(model_pp, dat_test_compare_final)
dat_test_pp
```

```{r}
# get vectors of the data that went into your model...
lumped_state <- dat_train_up_rf$state
lumped_style <- dat_train_up_rf$style
dat_compare_stan_clean <- dat_test_pp %>%
  mutate(state = if_else(state %in% lumped_state, state, 'Other'),
         style = if_else(style %in% lumped_style, style, 'Other'))
```

```{r}
predictions <- predict(model_rf, dat_compare_stan_clean)
dat_compare_stan_clean$Class <- predictions
```

```{r}
dat_compare_stan_clean$Class
```

```{r}
dat_train_up_rf %>% 
  select(Class, style) %>% 
  filter(style != "Other") %>% 
  filter(Class == 4)
```

#Providing recommendations to beer customers 


```{r}
new_beer <- tibble(beer_name = c('bud_light', 'guinness', 'red_stripe'), 
                      abv = c(0.06, 0.045, 0.51), 
                      ibu = c(24, 65, 82))
```










# ---- Additional Analysis ----  


```{r}
pred_test <- predict(model_rf, newdata = dat_test_pp)
pred_test
```

```{r}
pred_test[1]
```

```{r}
pred_final <- model_rf$finalModel$predictions %>% 
  tibble::enframe(name = NULL)
#pred_final
```

```{r}
pred_final %>% 
  filter(value == 3)
```

```{r}
model_rf$finalModel$predictions
```

```{r}
dat_train_rf %>% 
  filter(Class == 3) %>% 
  filter(style != "Other") %>% 
  filter(state != "Other")
```

