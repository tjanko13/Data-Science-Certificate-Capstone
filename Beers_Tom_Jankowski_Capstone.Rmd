---
title: "Canned Craft Beer Recommender.Rmd"
author: "Tom_Jankowski"
date: "10/14/2019"
output: pdf_document
toc: true
toc_depth: 3
number_sections: true
theme: united
highlight: tango
---

# Canned Craft Beer Recommender Application  
## Analysis in R  image: ![](path/to/smallorb.png)  
### by Tom Jankowski  

# Package and Library installation and loading.  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("tidyverse")
library("rattle")
library("rpart")
library("caret")
library("ranger")
library("lubridate")

# Set Seed
set.seed(123)
```

# Canned beer dataset obtained from kaggle.com:  
## [link] (https://www.kaggle.com/nickhould/craft-cans). 

The dataset consists of two files:  
  - beers.csv (2410 obs. of 8 variables).  
  - breweries.csv (558 obs of 4 variables).  
More detailed analysis of each dataset is provided in Exploratory Data Analysis (EDA) section.

```{r}
beers <- read_csv('beers.csv')
breweries <- read_csv('breweries.csv')
```

# Initial EDA on the **beers** dataset.  

## Descriptive statistics provides a quick summary of the features in the beers dataset.  
```{r}
summary(beers)
```

## Glimpse provides a quick look at the actual data values.  
```{r}
glimpse(beers)
```

## I need to determine the sum and proportion of missing values.  
```{r}
colSums(is.na(beers))
```

# NAs 
```{r}
round(colSums(is.na(beers)) / nrow(beers), 4)
```
It appears that there are .21% (5 obs.) missing in the **style** column. These are of no concern since there is a brewery_id for each missing style, and I can obtain the missing values from the brewery websites. The larger concern in the 41.7% (1005 obs.) missing values in the **ibu** column. These missing values, along with the 2.57% (62 obs.) in the **abv** column will be imputed using PreProcessing, which is part of the 'caret package'.

# Initial EDA on the **breweries** dataset.  

## Descriptive statistics provides a quick summary of the features in the beers dataset.  
```{r}
summary(breweries)
```

## Glimpse provides a quick look at the actual data values.  
```{r}
glimpse(breweries)
```
## I need to determine the sum and proportion of missing values.  
```{r}
colSums(is.na(breweries))
```
The **breweries** dataset contains no missing values. 

## Left Join  
To work with both datasets, I will need to perform a left join (beers to breweries). Here I am creating a new data frame named **dat**.
```{r}
dat <- beers %>% 
left_join(breweries, by = c('brewery_id' = 'X1'))
```

The column names need cleaning. Here I will rename some of the columns so they are more readable, and not duplicative. This will require removing the **X1** id, **id**, and **brewery_id** columns as they will not be useful in the analysis. Also, for readability, I will change the beer name column **name.x** to beer_name and the **name.y** column to brewery_name. Here I am creating a new data frame named **dat_selected**.

```{r}
dat_selected <- dat %>%
  rename(beer_name = name.x) %>% 
  rename(brewery_name = name.y) %>% 
  select(-id, -brewery_id, -X1)
```

The new **dat_selected** dataframe contains 2410 observations and 8 columns.

# Handling NAs  
Now, I must deal with the missing values in the data frame. First, since there are only 5 NA observations in the **style** column, I will replace the missing values with the actual values as obtained from the breweries respective websites.
```{r}
# Replacing the 3 NAs in the style column with actual values 
dat_selected[854, 4] <- "Scottish Ale"
dat_selected[567, 4] <- "Abbey Single Ale"
dat_selected[867, 4] <- "MÃ¤rzen / Oktoberfest"

# Adding beer name to a missing value
dat_selected[567, 3] <- "Belgian Dubbel"

# Replacing NAs in the abv column with known values 
dat_selected[567, 1] <- "0.076"
dat_selected[316, 1] <- "0.062"
dat_selected[317, 1] <- "0.034"
dat_selected[318, 1] <- "0.054"
dat_selected[319, 1] <- "0.055"
dat_selected[465, 1] <- "0.072"
dat_selected[542, 1] <- "0.050"
dat_selected[656, 1] <- "0.060"
dat_selected[657, 1] <- "0.060"
dat_selected[724, 1] <- "0.055"
dat_selected[731, 1] <- "0.061"
dat_selected[733, 1] <- "0.058"
dat_selected[925, 1] <- "0.065"
dat_selected[1031, 1] <- "0.050"
dat_selected[1118, 1] <- "0.070"
dat_selected[1169, 1] <- "0.051"
dat_selected[1170, 1] <- "0.050"
dat_selected[1171, 1] <- "0.052"
dat_selected[1172, 1] <- "0.050"
dat_selected[1173, 1] <- "0.047"
dat_selected[1174, 1] <- "0.051"
dat_selected[1354, 1] <- "0.058"
dat_selected[1557, 1] <- "0.070"
dat_selected[1637, 1] <- "0.055"
dat_selected[1668, 1] <- "0.065"
dat_selected[1814, 1] <- "0.060"
dat_selected[1888, 1] <- "0.058"
dat_selected[1970, 1] <- "0.056"
dat_selected[2045, 1] <- "0.045"
dat_selected[2187, 1] <- "0.052"
dat_selected[2338, 1] <- "0.070"
dat_selected[2348, 1] <- "0.055"

# Replacing NAs in ibu column with known values
dat_selected[567, 2] <- "25"
dat_selected[1, 2] <- "18"

# Delete 2 rows that are not actually beers
dat_selected <- dat_selected[-c(1555, 1556), ]

# Reassign to a new df 
dat_na_clean <- dat_selected
```

After cleaning the NAs, the data now contains 1001 NAs in the **ibu** column and 28 NAs in the **abv** column. These will be addressed later by imputed using PreProcessing.

```{r}
colSums(is.na(dat_na_clean))
```

One last clean-up activity includes setting the **abv** data to 4 decimal places to ensure consistency.  

```{r}
dat_abv_round <- dat_na_clean %>% 
  mutate(abv = round(abv, 4))
```

# Exploratory Data Analysis (EDA)  

With a joined and clean dataset, I will analyze the data to identify distributions and any variable relationships. The first analysis that interests me is the beer styles that are most common. I will use a bar chart to show this distribution. We can see that IPAs, Pale ales and other ales dominate the most common styles.

```{r}
dat_na_clean %>% 
  group_by(style) %>%
  summarise(count = n()) %>%
  filter(count > 50) %>%
  ggplot(aes(reorder(style, count), count)) +
  geom_col(fill = "tan") +
  coord_flip() +
  labs(title = "Top Beer Styles", subtitle = "Greater than 50 beers", x = "Sum of Beer Styles > 50", y = "Beer Styles")
```



```{r}
top_10_states <- dat_na_clean %>% 
  group_by(state) %>% 
  summarise(top_10 = n()) %>% 
  arrange(desc(top_10)) %>% 
  top_n(10)

top_10_states
```


