---
title: "Canned Craft Beer Recommender.Rmd"
author: "Tom_Jankowski"
date: "10/14/2019"
output: pdf_document
toc: true
toc_depth: 3
number_sections: true
theme: united
highlight: tango
---

# Canned Craft Beer Recommender Application  
## A Beerage of Choices!
### Analysis in R -- by Tom Jankowski  

# Package and Library installation and loading.  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#update.packages(ask = FALSE)
#install.packages("rstan")
#install.packages('dendextend')
#install.packages("ggdendro")
#install.packages('ape')
#install.packages("caret")
library("ape")
library("tidyverse")
library("rattle")
library("rpart")
library("caret")
library("ranger")
library("lubridate")
library("dendextend")
library("gridExtra")
library("ggdendro")
library("ggplot2")

# Set Seed
set.seed(123)
```

# Dataset
## Canned beer dataset obtained from kaggle.com: [link] (https://www.kaggle.com/nickhould/craft-cans). 

The dataset consists of two files:  
  - beers.csv (2410 obs. of 8 variables).  
  - breweries.csv (558 obs of 4 variables).  
More detailed analysis of each dataset is provided in Exploratory Data Analysis (EDA) section below.

```{r}
beers <- read_csv('beers_updated.csv')
breweries <- read_csv('breweries.csv')
```

# Craft Canned Beer Recommender Application -- Business Case  

Craft beer drinkers use different forms of information to select a beer. These include beer price, style, beer name, labeling, alcohol by volume (abv), international bitterness units (ibu), flavor profile, brewery, and the access they have to beers in thier local city, state, and brewery taphouses. Unless you live under a rock, you've no doubt noticed the booming craft beer market. According to the Brewers Association - an American trade group representing craft brewers, suppliers, and distributors, sales account for 24% of the U.S. beer market worth over $114 billion. Beer in the U.S. is manufactured by more than 7,000 breweries, which range in size from industry giants to brew pubs and microbreweries. With thousnds of brews to choose from, how do beer lovers choose a beer among a dizzying array of beer options. This is where the **Craft Canned Beer Rcommender App** helps make these choices a bit easier. The **Craft Canned Beer Rcommender App** is designed to help customers of beer retailers (such as liqour stores, grocery stores, and convenient stores) choose a beer based on a set of criteria including: beer abv, beer ibu, beer name, beer style, brewery name, city and state. Reatilers who offer its customers with the option to use the Craft Canned Beer Rcommender App will provide a better service to its customers increasing customer satisfation and loyalty, which increase sales and profit.


# Data cleaning and wrangling on the **breweries** dataset.  

## Descriptive statistics provides a quick summary of the features in the beers dataset.  

```{r}
summary(beers)
```

## Glimpse provides a quick look at the actual data values in the beers dataset.  

```{r}
glimpse(beers)
```

## Data cleaning and wrangling on the **breweries** dataset.  

## Descriptive statistics provides a quick summary of the features in the breweries dataset.  

```{r}
summary(breweries)
```

## Glimpse provides a quick look at the actual data values in the breweries dataset.  

```{r}
glimpse(breweries)
```

## Join the 2 datasets  
### Left Join  

To work with both datasets, I will need to perform a left join (beers to breweries). Here I am creating a new data frame named **dat**.
```{r}
dat <- beers %>% 
left_join(breweries, by = c('brewery_id' = 'X1'))
```

## A glimpse at the joined dataset shows my columns, datatypes, and sample values.  

```{r}
glimpse(dat)
```

As seen above, the column names need cleaning. Here I will rename some of the columns so they are more readable, and not duplicative. This will require removing the **X1** id, **id**, and **brewery_id** columns as they will not be useful in the analysis and modeling. Also, for readability, I will change the beer name column **name.x** to beer_name and the **name.y** column to brewery_name. Here I am creating a new data frame named **dat_selected**.

```{r}
dat_selected <- dat %>%
  rename(beer_name = name.x) %>% 
  rename(brewery_name = name.y) %>%
  mutate(ounces = round(ounces, 0)) %>% 
  mutate(ounces = as.factor(ounces)) %>% 
  select(-id, -brewery_id, -X1)
```

The new **dat_selected** dataframe contains 2410 observations and 8 columns.

# Handling Missing Values  
# Handling NAs  

I need to determine the sum and proportion of missing values in my joined dataset. As seen below, It appears that I have a number of missing values across the columns that must be addressed.

```{r}
colSums(is.na(dat_selected))
round(colSums(is.na(dat_selected)) / nrow(dat_selected), 4)
```

The .08% (2 obs.) missing values in the **style** column are not of concern since after examining these rows, I have determined that they are inaccurate and do not actually contain beer data. They will be deleted.

```{r}
dat_selected <- dat_selected[-c(1555, 1556), ]
```

```{r}
dat_selected %>% 
  group_by(brewery_name) %>% 
  summarise(n=n())
```


The larger concern is the 41.62% (1003 obs.) missing values in the **ibu** column. These missing values, along with the 1.16% (28 obs.) in the **abv** column could be handled in a number of ways. To determine a course of action, I will examine any potential associations between **ibu** and other variables.   

First I will examine the distribution of ibu NAs in the style column. 

```{r}
dat_selected %>% 
  group_by(style) %>% 
  filter(is.na(ibu)) %>% 
  count() %>% 
  ggplot(aes(x=style, y = n)) +
  geom_point()
```
The proportion of ibu NAs related to syle don't appear to have a relationship.

```{r}
ibu_na <- dat_selected %>% 
  group_by(style) %>% 
  filter(is.na(ibu)) %>% 
  summarise(ibu_na = n()) %>%
  arrange(desc(ibu_na)) %>% 
  ungroup() %>% 
  select(ibu_na)
ibu_na
```

```{r}
ibu_non_na <- dat_selected %>% 
  group_by(style) %>% 
  filter(!is.na(ibu)) %>% 
  summarise(ibu_value = n()) %>%
  arrange(desc(ibu_value)) %>% 
  ungroup() %>% 
  select(ibu_value)
ibu_non_na
```

## ABV NAs -- Analysis of missing values  

A look at the missing abv values.

```{r}
dat_selected %>% 
  group_by(style) %>% 
  filter(is.na(abv)) %>% 
  count() %>% 
  ggplot(aes(x=style, y = n)) +
  geom_point()
```

Missing abv values.

```{r}
abv_na <- dat_selected %>% 
  group_by(style) %>% 
  filter(is.na(abv)) %>% 
  summarise(abv_na = n()) %>%
  arrange(desc(abv_na))
#  ungroup()
#  select(abv_na)
abv_na
```

ABV values not missing.

```{r}
abv_non_na <- dat_selected %>% 
  group_by(style) %>% 
  filter(!is.na(abv)) %>% 
  summarise(abv_value = n()) %>%
  arrange(desc(abv_value))
#  ungroup()
#  select(abv_value)
abv_non_na
```

```{r}

```

# Exploratory Data Analysis (EDA)  

With a joined and clean dataset, I will analyze the data to identify distributions and any variable relationships. The first analysis that interests me is the beer styles that are most common. I will use a bar chart to show this distribution. We can see that IPAs, Pale ales and other ales dominate the most common styles.

```{r}
dat_selected %>% 
  group_by(style) %>%
  summarise(count = n()) %>%
  filter(count > 50) %>%
  ggplot(aes(reorder(style, count), count)) +
  geom_col(fill = "tan") +
  coord_flip() +
  labs(title = "Top Beer Styles", subtitle = "Greater than 50 beers", x = "Sum of Beer Styles > 50", y = "Beer Styles")
```

## Top 10 States for craft beer in the dataset.  

```{r}
top_10_states <- dat_selected %>% 
  group_by(state) %>% 
  summarise(top_10 = n()) %>% 
  arrange(desc(top_10)) %>% 
  top_n(10)

top_10_states
```

## ABV / IBU Relationship  

```{r}
dat_selected %>%
  select(ibu, abv) %>%
  ggplot(aes(abv, ibu)) + 
  geom_point(alpha = .4) +
  geom_smooth(method = lm, color = 'blue')
```

```{r}
dat_selected %>%
  group_by(state) %>%
  mutate(mean_ibu = mean(ibu, na.rm = TRUE)) %>%
  ggplot(aes(x = reorder(state, -mean_ibu), y = ibu, fill = mean_ibu)) + 
  geom_boxplot() + 
  labs(x = "state", y = "Beer IBU", title = "Who Likes Bitter Beer?")
```

```{r}
dat_abv_clean <- dat_selected %>% 
  group_by(style) %>% 
  mutate(abv = if_else(is.na(abv), mean(abv, na.rm = TRUE), abv),
         ibu = if_else(is.na(ibu), mean(ibu, na.rm = TRUE), ibu)) %>% 
  ungroup()
```

```{r}
dat_ibu_clean <- dat_abv_clean %>%
  group_by(style) %>% 
  mutate(ibu = if_else(is.na(ibu), mean(ibu), ibu)) %>% 
  ungroup()
```

```{r}
dat_clean_cases <- dat_ibu_clean %>% 
  filter(complete.cases(dat_ibu_clean))
```

```{r}
dat_clean <- dat_clean_cases %>%
  mutate(ibu = round(ibu, 0),
         abv = round(abv, 3))
dat_clean
```


```{r}
colSums(is.na(dat_clean))
round(colSums(is.na(dat_clean)) / nrow(dat_clean), 4)
```

## Looking at duplicates in the beer_name column  
```{r}
dat_clean %>% 
  group_by(beer_name, ounces) %>% 
  count() %>% 
  arrange(beer_name) %>% 
  arrange(desc(n))
```

```{r}
#dat_selected$beer_name[duplicated(dat_selected$beer_name)]
```

## Removing columns with duplicate beer names.  
```{r}
#dat_no_dups <- dat_clean %>%
#  distinct(beer_name, .keep_all = TRUE)
```

## Rownames conversion for Hierachical Clustering  
```{r}
dat_model <- dat_clean %>% 
  mutate(beer_name = paste0(beer_name, "-", ounces)) %>% 
  distinct(beer_name, .keep_all = TRUE) %>% 
  mutate(id = row_number())
```

## Data Split Train / Test  based on a predefined set of known and recognizable beer names  
```{r}
test_beer_names <- c("Fat Tire Amber Ale-12", "Fat Tire Amber Ale-16", "White Rascal-12", "Boston Lager-12",
                     "Boston Lager-16", "Mirror Pond Pale Ale-12", "1554 Black Lager-12", "Dale's Pale Ale (2012)-12",
                     "Mama's Little Yella Pils-12", "Mama's Little Yella Pils-19", "Monarch Pilsner-12",
                     "Upslope Brown Ale-12", "G'KNIGHT (12 oz.)-12", "G'KNIGHT (16 oz.)-16", "Hop Crisis-12",
                     "Sculpin IPA-12", "Todd the Axe Man-16", "Wyoming Pale Ale-16", "Samuel Adams Winter Lager-12",
                     "Laughing Dog Cream Ale-12", "Apricot Blonde-12", "TailGate Hefeweizen-12",
                     "TailGate Hefeweizen-24", "Easy Day Kolsch-12", "Kilt Lifter Scottish-Style Ale-12",
                     "Grateful White-12", "Hazy Day Belgian-Style Wit-16", "Vivant Tripel (2012)-16", "Righteous Ale-16",
                     "Crabtree Oatmeal Stout-16")

dat_test <- dat_model %>%
  filter(beer_name %in% test_beer_names)

dat_train <- dat_model %>% 
 anti_join(dat_test, by = 'id') %>%
 select(-id)

dat_test <- dat_test %>% 
  select(-id)
```

### Original train / test split code  
```{r}
#dat_model <- dat_model %>% 
#  mutate(id = row_number())

#dat_train <- dat_model %>%
#  sample_frac(0.75)

#dat_test <- dat_model %>%
# anti_join(dat_train, by = 'id') %>%
# select(-id) %>%
#  column_to_rownames("beer_name")

#dat_train <- dat_train %>%
# select(-id) %>%
# sample_n(50) %>% 
# column_to_rownames("beer_name")
```

# ----- MODELING STARTS HERE ----- ###

## Preprocessing  
Pre-processing using **Standardization**, which combines both scaling and centering transformations.   
```{r}
model_pp <- preProcess(dat_train, method = c('center', 'scale'))
dat_train_pp <- predict(model_pp, dat_train) %>% 
  sample_n(30)
dat_train_pp
```


```{r}
dat_train_rownames <- dat_train_pp %>%
  column_to_rownames("beer_name")

dat_test_rownames <- dat_test %>%
  column_to_rownames("beer_name")
```

## Hieracrhical Clustering Model   
```{r}
distance_data <- dist(dat_train_rownames, method = 'euclidean')
hc_complete <- hclust(distance_data, method = 'complete')
plot(hc_complete, hang = -1, cex = 0.6)
```

```{r}
hc_cut <- cutree(hc_complete, 4)
dat_train_pp <- dat_train_pp %>%
  mutate(Class = as.factor(hc_cut))

#hc_cut
```


```{r}
a <- cutree(hc_complete, 4)
dat_train_rownames$cluster <- a
dat_train_rownames %>%
  group_by(cluster) %>%
  count() %>%
  arrange(n)

dat_train_rownames %>%
  ggplot(aes(x = abv, y = ibu)) +
  geom_point()
```


```{r, fig.height=10, fig.width=10}
k_val <- 6

hc_complete_dendro <- as.dendrogram(hc_complete)

dend_colored <- hc_complete_dendro %>%
  color_branches(k = k_val) %>%
  color_labels(k = k_val) %>% 
  set("labels_cex", .6)

plot(dend_colored, cex = 0.6, type = "rectangle")

```

```{r}
cols <- c("#a9a9a9", "#1f77b4", "#ff7f0e", "#2ca02c")

p <- ggdendrogram(hc_complete_dendro,
                   direction   = "tb",
#                   scale.color = cols,
                   label.size  = 2.5,
                   branch.size = 0.5,
                   expand.y    = 0.2)

mytheme <- theme(axis.text          = element_text(color = "blue"),
                 panel.grid.major.y = element_line(color = "tan",
                                                   size  = 0.25))
p + mytheme
```

# Analysis of Distance Data  
```{r}
dist_data <- as.tibble(table(distance_data)) %>% 
  rename(cluster = n) %>% 
  arrange(cluster)
  

dist_data
```

```{r}
dist_data[1]
```

```{r}
pred_test <- predict(model_pp, dat_test)
pred_ibu <- pred_test$ibu
pred_abv <- pred_test$abv
dat_test_standardized <- pred_test %>%
  mutate(abv = pred_abv, ibu = pred_ibu) %>% 
  mutate(Class = as.factor(hc_cut))

dat_test_standardized
```

```{r}
predictions <- predict(model_pp, dat_test_standardized)
predictions
```


```{r}
confusionMatrix(predictions, dat_test_standardized$Class)
```

# ---- Classification Model ----
## Predicting cluster  

```{r}
train_control <- trainControl(method = 'cv', number = 5, allowParallel = TRUE)

model_rf <- train(dat_train_pp %>% select(-Class), dat_train_pp$Class, method = 'ranger', trControl = train_control)

model_rf
```

```{r}
model_rf
```


